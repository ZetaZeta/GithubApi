To install and run:
* In IntelliJ, open the project, build to install dependencies via Gradle, and hit run.
* Tests can be run in the test directory or via right-click -> run all tests.
* Alternatively, to run via Gradle, run:
"gradlew build" to build.
"gradlew bootRun" to start the server (make sure port 8080 is available)
"gradlew test" to run tests
(Or just "gradle" if gradle is already installed.)

I generally tried to keep things as simple as possible, while using a structure
that would allow for later expansion. The client, endpoint controller / handler,
and models are separated out to allow for later expansion and easy reuse.

The models contain a lot of fields we don't yet need; my experience from working on integrations is that
it's better to go with more comprehensive models when it's easy to do so, since that makes future
expansion easier by making it more clear what info the endpoint provides.

Some shortcuts taken for time:
- Used a single type of end-to-end test to test live calls to Github, making one-button testing-everything easier.
  In actual production the server would be mocked for unit tests, and end-to-end testing would
  be done elsewhere.
- com.combiner.githubapi.TestUtils just has the JSON inline rather than loading it from a file.
- The error handling currently just relays the error from Github, with its error code; this makes sense for the most likely errors
(eg. 404) but some of them would probably want some detailed handling and logging.
- The cache is just a basic default cache in memory.